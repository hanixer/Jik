(define (state->string astate)
  (list->string (map (lambda (x) (if (= x 0) #\space #\@)) 
                     (vector->list astate))))
(define *init-state* (make-vector 80))
(vector-set! *init-state* 40 1)
(define *rules*
  '(((0 0 0) . 0)
    ((0 0 1) . 1)
    ((0 1 0) . 1)
    ((0 1 1) . 1)
    ((1 0 0) . 1)
    ((1 0 1) . 1)
    ((1 1 0) . 1)
    ((1 1 1) . 0)))
(define (vector-wrap-ref vec position)
  (vector-ref vec (modulo position (vector-length vec))))
(define (get-neighbors state position)
  (map (lambda (x) (vector-wrap-ref state (+ x position))) 
       (list -1 0 1)))
(define (state->neighbor-list state)
  (define (list-builder pos accum-list)
    (if (< pos 0) 
        accum-list
        (list-builder (- pos 1) (cons (get-neighbors state pos) accum-list))))
    (display "state->neighb...")
    (newline)
    (list-builder (- (vector-length state) 1) (list)))
(define (apply-rules neighbor-list)
  (list->vector (map (lambda (neighbors) (cdr (assoc neighbors *rules*))) neighbor-list)))
(define (run-and-display state iters)
  (begin
    (display "hello")
    (newline)
    (display (state->string state))
    (newline)
    (if (= iters 0) 
        (display "end")
        (run-and-display (apply-rules (state->neighbor-list state)) (- iters 1)))))
;; we might call it like this:
(run-and-display *init-state* 31)